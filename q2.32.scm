; 集合は相異なる要素のリストで表現できる。「"集合の全ての部分集合"の集合」を、リストのリストで表現できる。
; 与えられた集合が(1 2 3)のとき、「"集合の（ry」は(() (3) (2) (1) (1 2) (1 3) (2 3) (1 2 3)) である。

(define (subsets s)
  (if (null? s)
    (list ())
    (let ((rest (subsets (cdr s))))
      (append rest (map xxx_proc_xxx rest)))))

; なるほどわからん。Wiki見よう。
; http://wiki.drewhess.com/wiki/SICP_exercise_2.32
; 考え方。
; (1 2 3) のすべての部分集合の集合をSとすると、
; (1 2 3 4) のすべての部分集合の集合は、Sに加えて、Sの各要素（それぞれの要素は部分集合である）に4を加えたものとなる。
;
; 例: (2 3)のすべての部分集合の集合は
; (() (2) (3) (2 3))
; であり、(1 2 3)のすべての部分集合の集合は
; (() (2) (3) (2 3) (1) (1 2) (1 3) (1 2 3)) ...である。故意に並び替えたが、ここで加わったものは
; (1), (1 2), (1 3), (1 2 3)の4つ。これは、(2 3)のすべての部分集合に対して、1を加えた集合達である。
; この再帰構造を発見できれば、あとはコードに落としていけば良い。

; restをletで定義しているが、これは「一手前」の状態であると言える。
; 「一手前」から現状に到達するために加えられたものはrestから弾かれたもの、すなわち(car s)である。
; mapの第一引数に渡す手続きは、lambdaで表現して、
; (lambda (x) (cons (car s) x)) となる(xに入るものはrestである)。よって答えは

(define (subsets s)
  (if (null? s)
    (list ())
    (let ((rest (subsets (cdr s))))
      (append rest (map (lambda (x) (cons (car s) x)) rest)))))

; gosh> (subsets (list 1 2 3))
; (() #0=(3) #1=(2) #2=(2 . #0#) (1) (1 . #0#) (1 . #1#) (1 . #2#))
;
; できた！けど#n=はなんだろう。
