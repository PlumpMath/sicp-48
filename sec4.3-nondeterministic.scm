(load "./sec4")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 4.3. Schemeの変形 -- 非決定性計算(Nondeterministic Computing)
;;   そそる響き.

;; 例. ２つの整数のリストがあり, そこから1個ずつとった数の和が素数になるかどうか調べる.
;;     フィルタする方法を3章で学んだ.
;;     非決定性計算は, 要求されることをプログラムに書き下す形で実現する.
(define (prime-sum-pair list1 list2)
  (let ((a (an-element-of list1))
        (b (an-element-of list2)))
    (require (prime? (+ a b)))
    (list a b)))

;; 動き方イメージ
;; (prime-sum-pair '(1 3 5 8) '(20 35 110))
;;   => (3 20)

;; ポイント: 非決定性計算においては "式はひとつ以上の可能な値を持ち得る".
;;           .oO (単純な置き換えモデルがもはや通用しないか...)

; > 非決定性評価とストリーム処理で惹き起こされる時間の異なる姿を対照させることは有用である.
; > ストリーム処理は, 可能性ある解答のストリームが集められる時と, 実際のストリーム要求が作り出される時を切り離すのに遅延評価を使う. 評価器は, 可能な答のすべては無時間の並びとしてわれわれの前に存在するという幻想を作る.
; > 非決定性計算では, 式は一連の選択で決められる, 可能な世界の集合の探索を表す. 可能な世界の中には, 行き止まりのものもあるが, 残りは有用な値を持つ. 非決定性プログラムの評価器は, 時は分岐し, プログラムは異なる可能な実行履歴を持つという幻想を作る.


;;; 特殊形式 amb と探索 ;;;
;; ambの使い方イメージ (実装は sec4.3.2にて.)
;; 引数付きのambは引数(=候補)の中からひとつの値を"ambivalentに"返す.
;    (list (amb 1 2 3) (amb 'a 'b))
;      => (1 a), or (1 b), or (2 a), or (2 b), or (3 a), or (3 b)

;; 引数なしのambは"受け入れられる値がない" => たどり着いてしまうと失敗になる式, と考える.
;; これを使えばrequireも実装できる.
(define (require p)
  (if (not p) (amb)))

(define (an-element-of items)
  (require (not (null? items)))
  (amb (car items) (an-element-of (cdr items))))

;; ambは無限の表現も可能である. まぁ3章の無限streamと同じだね
(define (an-integer-starting-from n)
  (amb n (an-integer-starting-from (+ n 1))))

;;; ambのdriver-loop ;;;
;; try-againという記号でコントロールする.


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 4.3.2. 非決定性プログラムの例
;;   ambを実装するよ!



