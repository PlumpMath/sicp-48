;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;   1.1 プログラムの要素
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;     1.1.1 式
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; > 式の並びをかっこで囲んで手続きの作用を表現する上のような式を組み合わせ(combinations)という.
(+ 1 2)
  ;; + => operator(演算子)
  ;; 1, 2 => operands(被演算子)
;; 演算子が指定する手続きを, "被演算子の値"である引数に作用させて得る.
;; 演算子, 被演算子は構文上の話で, 手続きとその引数は実際の"値"のレイヤーを話している

;; 前置記法のメリット
;;   1. 任意個の引数を書ける.
;;   2. combinationsを入れ子に書ける


;;;     1.1.2 名前と環境
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; > プログラム言語の重要な点は, 名前を使って計算オブジェクトを指す手段を用意することである. オブジェクトを値(value)とする変数(variable)を識別するものが名前である.
;; 名前 = 変数識別子@CTMCP
;; 名前の対応付けはdefineで行う.
(define hoge 3)

;; > 値と記号を対応づけ, 後にそれが取り出せるためには, 解釈系は名前とオブジェクトの対を見失わないため, 何か記憶を保持している(中略)
;; > この記憶を環境(environment)という.
;; より正確には, 後になって「計算は多くの異なる環境に関わる」ということが分かる故に大域環境(global environment)とも.


;;;     1.1.3 組合せの評価
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; 組合せの評価 -- 以下を末端から繰り返して上る(tree accumulation).
;;   1. 組合せの部分式を評価する
;;   2. 最左部分式の値である手続き(演算子)を, 残りの部分式の値である引数(被演算子)に作用させる.

;; (1)で置き換えまくってると, 評価する必要のない(self-evaluatingな)式に出会う.
;; たとえば数字, 基本演算子(加減乗除etc), または"名前".
;; 基本演算子はunderlyingな機械の命令に対応している(sec4では下層のScheme).

;; まとめると組合せの評価で出現する式は以下のいずれかに分類される. とくにLispは単純.
;;   * 基本式(variable, number, quote etc)
;;   * 特殊形式(define, if, cond, begin, lambda etc)


;;;     1.1.4 合成手続き
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; 手続き定義を学ぶ. 自分で作った手続きを合成手続きと読んでるぽい?
(define (square x) (* x x))
;; xは代名詞のようなもの. 局所的な名前.


;;;     1.1.5 手続き作用の置き換えモデル
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; 1.1.3で見た組合せ評価は, 合成手続き(自分で定義した手続き)がある場合どうなるだろうか? そこで出てくるのが
;;    置き換えモデル
;; である. すなわち子要素の手続き作用結果を, そのまま元の式の該当箇所にはめ込んでも問題ない.

;; sec3でプログラムに代入を許可すると, 状態によって変化し一意に決まらなくなり純粋な置き換えモデルは崩れる.
;; 代入を許すことで変数は"値の別名"から"状態を保持する箱"へと変化してしまう.
;; Clojure, Erlang, Haskellなどは変数への再代入を許可していない.

;; 作用的順序 vs 正規順序
;; "評価"の順序についてさらっと流してきたが, ここもいくつか選択肢がある.
;;   A. まず演算子と被演算子を評価し, 次に結果の手続きを結果の引数に作用させる
;;   B. その値が必要になるまで被演算子を評価しない.
;; いままで見てきたのは(A)だが, (B)という方法もある. 置き換えを繰り返し, 基本演算子だけになったらそこで初めて評価する.
;; 要するに(B)は遅延評価で, 後に出てくるSICPの実装ではlambda式の中にpackしておき必要なときforceする方法が対応するはず.

;; (A). 作用的順序(applicative-order (evaluation))
(sum-of-squares (+ 5 1) (* 5 2))
(sum-of-squares 6 10)
(+ (square 6) (square 10))
(+ 36 100)
136

;; (B). 正規順序(normal-order (evaluation))
(sum-of-squares (+ 5 1) (* 5 2))
(+ (square (+ 5 1)) (square (* 5 2)))
(+ (* (+ 5 1) (+ 5 1)) (* (* 5 2) (* 5 2))) ;; すべて展開され, ようやく最初のoperandsが"必要とされ"る.
(+ (* 6 6) (* 10 10))
(+ 36 100)
136

;; 大事なこととして
;;   「置き換えモデルが成り立つ限り, 正規順序と作用的順序で評価した結果は必ず等しくなる」
;; 置き換えモデルの破綻については上述の通り.

;; 実際Lispは(A)の作用的順序を使っている. 理由は
;;   * 正規順序で(+ 5 1)が2回出てくるように, 同じ式を何回も評価しなくていい
;;   * 置き換えモデルが成り立たなくなった場面では, 正規順序が複雑になる.


;;;     1.1.6 条件式と述語
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; 特殊形式: cond, if, and, or
;; 通常の手続き: not

;; => q1.01.scm
;; => q1.02.scm
;; => q1.03.scm
;; => q1.04.scm
;; => q1.05.scm


;;;     1.1.7 例: ニュートン法による平方根
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; 数学定義 != 手続
;; 違いは「手続きは効果的である必要があります」
;; 別の訳「実効的でなければならない」いずれにせよいみわからん.
;; 数学の定義そのままでは手続きとして使えない事を言ってるんだと思う.

;; 数学では宣言的(what is)記述
;; コンピュータでは手続き的(how to)記述を行う
;; -- Prolog等論理プログラミングでは宣言的に書ける.

;; 平方根の定義を宣言的に書くだけでは使えない.
;; 手続き的な平方根の求め方の一つがニュートン漸次接近法.
;; xの平方根を求めるとき, 最初の推定値yをとり, さらにx/yを次の推定値として無限に繰り返す(適当な所で止める)
;; 正解の値に振動しながら収束していく極限を考える.

(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x ) x)))

(define (improve guess x)
  (average guess (/ x guess)))

(define (average x y)
  (/ (+ x y) 2))

(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))

;; 推定値を1.0の決め打ちから始める使い方
(define (sqrt x) (sqrt-iter 1.0 x))

(sqrt 9) ;; 3.00009155413138

;; => q1.06.scm
;; => q1.07.scm
;; => q1.08.scm

;;;     1.1.8 ブラックボックス抽象としての手続き
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; the only process that users really need is "sqrt",
;; so we can hide othre processes into it.
(define (sqrt x)
  (define (good-enough? guess)
    (< (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
      guess
      (sqrt-iter (improve guess))))
  (sqrt-iter 1.0)
  )
